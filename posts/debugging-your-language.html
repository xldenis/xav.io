<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Xavier Denis - Debugging your own language</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,900" rel="stylesheet" type="text/css">
    </head>
    <body>
        <main role="main">

        <header>
            <nav>
                <h1 class="logo"><a href="../">xav.io</a></h1>
                <a href="../about.html">about</a>
            </nav>
        </header>

            <link rel="stylesheet" href="../css/highlighting.css" />
<article>
    <section class="header">
        <h2>Debugging your own language</h2>
        <date>Posted on 2018-06-06</date>
        
    </section>
    <section>
        <p>For the past year, I’ve been working on writing my own functional programming language. It’s taught me a lot already, and there’s still a lot more to learn. Recently, I improved the performance of of traits (typeclasses) significantly, but when I compared it to a ruby equivalent, it was still 4 times slower. Knowing that ruby isn’t a particularily fast language, and that 2 seconds to (naively) count the first 33 fibonacci numbers is a lot, I decided to investigate.</p>
<p>Looking over the core language output from the compiler and the corresponding LLVM IR, I didn’t see any obvious performance mistakes. The only thing that seemed to standout was <code>malloc</code>, since I needed to constantly allocate space for integers after every operation, it seemed like a reasonable candidate. But since the first step to optimization is to measure, I figured I needed to find a way to profile my code!</p>
<p>LLVM has support for tracking Debug Metadata [], but it requires me to annotate the IR the compiler produces with all sorts of information. It’s something I’d like to do soon but don’t have the time for yet. Hunting around the web led me to discover the <code>-debugify</code> pass, which attaches debug information to an IR file. This doesn’t give me <em>source</em>-level debugging but it’s more than good enough. Unfortunately <code>debugify</code> forgets to add a required <code>Debug Version Info</code> struct but it can easily be added by hand.</p>
<p>&lt; instrumented ir &gt;</p>
<p>Once I produced an instrumented binary, I was able to profile it with <code>Instruments.app</code> XCode’s profiler. It revealed exactly what I had suspected originally, a rare occurence! The calls to <code>malloc</code> were the ones taking up the runtime!</p>
    </section>
</article>


        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
        </main>

    </body>
</html>
